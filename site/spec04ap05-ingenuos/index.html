<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>Algoritmos ingênuos - CLP</title>
        <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../css/font-awesome-4.5.0.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="../css/highlight.css">
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->
	
	<script src="../js/jquery-1.10.2.min.js"></script>
        <script src="../js/bootstrap-3.0.3.min.js"></script>
        <script src="../js/highlight.pack.js"></script> 
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="..">CLP</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                    <li >
                        <a href="..">Apresentação</a>
                    </li>
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Especificações <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li >
    <a href="../spec01-hub/">Geral</a>
</li>
                            
  <li class="dropdown-submenu">
    <a href="#">CLP-coord</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../spec02-coord/">Geral</a>
</li>
            
<li >
    <a href="../spec02a-coord-Geohash/">Geohash</a>
</li>
            
<li >
    <a href="../spec02b-coord-S2/">S2</a>
</li>
    </ul>
  </li>
                            
<li >
    <a href="../spec03-via/">CLP-via</a>
</li>
                        </ul>
                    </li>
                    <li class="dropdown active">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Apêndices <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li >
    <a href="../locationCodes/">Levantamentos</a>
</li>
                            
<li >
    <a href="../spec04ap01-siglas/">Siglas</a>
</li>
                            
<li >
    <a href="../comparacao/">Comparações</a>
</li>
                            
<li class="active">
    <a href="./">Algoritmos ingênuos</a>
</li>
                            
<li >
    <a href="../spec04ap06-dadosCompl/">Dados complementares</a>
</li>
                            
<li >
    <a href="../spec04ap08-auxTec/">Detalhes técnicos</a>
</li>
                        </ul>
                    </li>
                    <li >
                        <a href="../assets/README/">Créditos</a>
                    </li>
                </ul>

            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                        <i class="fa fa-search"></i> Search
                    </a>
                </li>
                    <li >
                        <a rel="next" href="../comparacao/">
                            <i class="fa fa-arrow-left"></i> Previous
                        </a>
                    </li>
                    <li >
                        <a rel="prev" href="../spec04ap06-dadosCompl/">
                            Next <i class="fa fa-arrow-right"></i>
                        </a>
                    </li>
            </ul>
        </div>
    </div>
</div>

        <div class="container">
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="main active"><a href="#compactacao-ingenua">Compactação ingênua</a></li>
            <li><a href="#exemplo-novamente">Exemplo novamente</a></li>
        <li class="main "><a href="#fusao-intrelacada-ingenua">Fusão intrelaçada ingênua</a></li>
        <li class="main "><a href="#indexacao-ingenua-da-grade-municipal">Indexação ingênua da grade municipal</a></li>
            <li><a href="#rotulacao-ingenua-de-indices-contiguos">Rotulação ingênua de índices contíguos</a></li>
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<p><strong><center><big>Algoritmos ingênuos: soluções válidas</big></center></strong></p>
<p>O termo <em>algoritmo</em> em Computação é sinônimo de "receita" utilizada para fazer algo, como um cálculo. Fica caracterizado por seu nome, suas entradas e suas saídas:</p>
<ul>
<li>
<p>ENTRADAS: são os "ingredientes" que serão transformados em saídas, ou que estabelecem parâmetros de decisão para modificar a saída. Num algoritmo de CLP as entradas principais são as coordenadas geográficas.</p>
</li>
<li>
<p>SAÍDAS: é o resultado final, o "bolo" gerado pela receita &mdash; que num algoritmo de CLP é um código.</p>
</li>
<li>
<p>NOME: batizamos com nomes diferentes quando os resultados, entradas ou performance é diferente dos seus similares. <br/>NOME DE VARIANTE: mantemos o "nome de família", por exemplo Geohash36 é uma variante do Geohash que muda o resultado final e acrescenta algumas opções de entrada.</p>
</li>
</ul>
<p>O Geohash e o PlusCode são nomes de algoritmos diferentes, que chegam a resultados diferentes, mas ambos calculados com rapidez e precisão.</p>
<p>Um <strong><em>algoritmo ingênuo</em></strong> seria aquele que ataca o problema de maneira direta e óbvia,  norteada pela intuição, sem maior preocupação com com a rapidez, ou casos anômalos. São importantes como referencial didático, para um primeiro contato do público leigo com o problema. Até pode calhar, mas raramente será considerado um algoritmo sério. Pode ser recomendado por exemplo para o uso em condições extremas, onde não existe acesso a bancos de dados.</p>
<p>A seguir os algoritmos principais envolvidos na abordagem mais direta do CLP-coordenada, que simplesmente toma um par de valores de latitude e longitude padrão (cada coordenadada com 7 a 10 dígitos), e a devolve a mesma coisa em uma representação comprimida, um código só de 6 a 10 dígitos.  Nesta seção serão detalhados na sua "receita ingênua", mas a sua modularização, em algoritmos menores, é válida para outros algoritmos.</p>
<p>Outras fontes de explicação: na <a href="../comparacao/">comparação</a> foram apresentados os principais "algoritmos sérios", e na <a href="../spec02-coord/">especificação das soluções CLP-coordenada</a> as suas principais variações.  No <a href="FAQ.md">FAQ</a> são respondidas perguntas que podem eventualmente ajudar o público leigo a entender o jargão e conceitos técnicos envolvidos.</p>
<h2 id="compactacao-ingenua">Compactação ingênua</h2>
<p>Algoritmo de conversão de coordenadas geográficas em CLP-coordenada através da "compactação ingênua".</p>
<ul>
<li>
<p>ENTRADAS: as coordenadas de um ponto sobre o território nacional, em formato decimal padrão. <br/>Exemplo  da <a href="..#latitude-longitude-e-contexto-a-solucao">apresentação</a>, o MASP em São Paulo, nas coordenadas <em>"-23.56151,-46.65596"</em>, com precisão de ~5m. A entrada pode ser expressa no padrão Geo URI,  <code>geo:-23.56151,-46.65596;u=5</code>, composta rigorosamente por:<br/><code>latitude</code> (primeira coordenada, "-23.56151" no exemplo)<br/><code>longitude</code> (segunda coordenada, "-46.65596" no exemplo)<br/><code>uncertainty</code> (abreviado <code>u</code> com valor 5 no exemplo)</p>
</li>
<li>
<p>ENTRADA OPCIONAL: o contexto em geral é "Brasil", de modo que na saída, o código resultante pode omitir o prefixo <code>BR</code>. <!-- Se o contexto for <code>BR-SP</code> pode-se omitir também o <code>SP</code> do resultado... Ver regras de contexto da Especificação --></p>
</li>
<li>
<p>SAÍDA: um só código compacto e reversível, que pode ser convertido de volta nas coordenadas da entrada pelo algoritmo inverso.</p>
</li>
</ul>
<p>O passo-a-passo da conversão da entrada em saída é o seguinte:</p>
<ol>
<li>
<p>Detecta-se através de um mapa oficial dos municípios, tal como o OpenStreetMap, qual o município da coordenada. O mapa retorna o seu identificador de município IBGE, <code>id_ibge</code>, a sua abreviação de 3 letras, <code>abbrev3</code> e os valores mínimos de latitude e longitude daquele município, <code>minlat</code> e <code>minlon</code>. <br/>No caso do exemplo temos  <code>id_ibge := 3550308</code>, <code>abbrev3 := "BR-SP-SPA"</code>, <br/><code>minlat := -24.007</code> e <code>minlon := -46.8264088</code><!-- Os dados básicos do município são ofertados pela Wikidata ou <a href="http://datasets.ok.org.br/city-codes">datasets.ok.org.br/city-codes</a>.--></p>
</li>
<li>
<p>Obtém-se as "coordenadas locais" subtraindo cada componente, ou seja, <br/><code>latitude_local := latitude - minlat</code>; <br/><code>longitude_local := longitude - minlon</code>. <br/>No exemplo resultaria em <code>latitude_local=0.44549</code> e <code>longitude_local=0.17045</code>.</p>
</li>
<li>
<p>Obtên-se um "numerão" a partir da normalização e "fusão" das coordenadas locais. <br/>A forma mais ingênua é concatenar, mas pode-se usar variantes como a "fusão por intercalação". A normalização consiste apenas em acrescentar zeros a esqueda da parte inteira ou à direita da parte fracionária, quando necessário. <br/>No exemplo: ... <code>numerao = normaliza(latitude_local,u) || normaliza(longitude_local,u)</code>.</p>
</li>
<li>
<p>Converte-se o numerão decimal para base32.<br/>Variantes podem considerar base36 ou base58, assim como diferentes alfabetos.</p>
</li>
<li>
<p>O código por fim é obtido</p>
</li>
</ol>
<h3 id="exemplo-novamente">Exemplo novamente</h3>
<p>Apenas apresentando em narrativa mais longa o que já foi indicado acima no passo-a-passo, e que o algoritmo ingênuo não fica muito atrás dos sofisticados Geohash e PlusCode.</p>
<table>
<thead>
<tr>
<th>Tecnologia de referência (código padrão) e resolução</th>
<th>Opção de CLP proposta</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><em>Ingênuo</em></strong> (<code>44OH8TL</code>)&nbsp; ~4x4 m</td>
<td><strong><code>SPA-44OH.8TL</code></strong></td>
</tr>
<tr>
<td><a href="http://geohash.org/6gycfqf0m"><em>Geohash</em></a> (<code>6gycfqf0m</code>)&nbsp; ~4x4 m</td>
<td><strong><code>SPA-YCFQ.F0M</code></strong></td>
</tr>
<tr>
<td><a href="http://geohash.org/6gycfqf0"><em>Geohash</em></a> (<code>6gycfqf0</code>)&nbsp; ~25x20 m</td>
<td><strong><code>SPA-YCFQ.F0</code></strong></td>
</tr>
<tr>
<td><a href="https://plus.codes/588MC8QV+CJ"><em>PlusCode</em></a> (<code>588MC8QV+CJ</code>)&nbsp; ~15x15 m</td>
<td><strong><code>SPA-C8QV+CJ</code></strong></td>
</tr>
</tbody>
</table>
<p><img alt="" src="../assets/masp-comparing2b.jpg" /></p>
<p>O CLP do MASP poderia ser formado só pelos dígitos das coordenadas, algo como <code>2356151,4665596</code>, mas ainda seriam 7+7=14 dígitos, muito longo para lembrar ou digitar.  As coordenadas podem ficar mais compactas se ao invés de serem representadas na base10 (decimal), usarmos a <a href="https://en.wikipedia.org/wiki/Base32">base32</a>, o que resultaria em <code>27STN,4EC7S</code>, 5+5 dígitos. Ainda melhor sem a vírgula, tudo num só numerão, pois a conversão trata ele como um todo e fica um dígito mais compacto, <code>LDNBRCHJS</code>... pronto, 9 dígitos!</p>
<p>Compactamos a informação original de 14 dígitos para 9, simplesmente estabelecendo uma convenção de representação mais adequada para um código... Podemos fazer melhor?  Sim, ainda sem recorrer a receitas numéricas complexas, podemos <strong>usar a informação de contexto</strong>. O contexto do MASP <strong>é o município</strong> de São Paulo, que podemos abreviar para <code>SP</code> já que é a capital do Estado &mdash; se fosse digigamos Piracicaba seria uma abreviação de 3 letras, <code>PIR</code>.</p>
<p>Se levar  em conta as coordenadas de todos os pontos internos ao traçado do município de São Paulo tem o mesmo prefixo, como latitude na forma "-23.5<i>etc</i>" e longitude "-46.6<i>etc</i>", podemos incluir o sigla <code>SP</code> do município no código e elinar dígitos redundantes do seu contexto. No caso do Geohash fazemos <a href="">cortando a parte inicial do código</a> que for comum a todos os pontos da cidade.</p>
<p>Matematicamente, há uma forma mais precisa do que cortar prefixos. Fazemos isso subtraindo a menor latitude (-24.007) e a menor longitude (-46.82641) o que resultaria em coordenadas 0.44549 e 0.17045 para o MASP, concatendo-as num numerão e depois representando em base32 resultaria em <code>44OH8TL</code>, ou seja, o código mais curto e palatável para o ser humano, <code>SP-44OH.8TL</code>. Que mágica, temos uma receita simples e um código compacto!</p>
<p>O código <code>SPA-44OH.8TL</code> é bem <strong>mais fácil de lembrar</strong> do que as coordenadas, porque a sigla do município é amigável, e o restante dos caracteres é mais curto do que um número de telefone. Claro, esse <em>não é o padrão proposto</em> pois ele carece de outras características que o Geohash e outros padrões oferecem. <!-- &mdash; e por isso estamos empreendendo um grande estudo.--> O que precisa ficar claro é que a tecnologia pode ser simples, a mágica está em estabelecer um consenso no que queremos, não em encontrar uma receita complexa para resolver o problema.</p>
<h2 id="fusao-intrelacada-ingenua">Fusão intrelaçada ingênua</h2>
<p>A fusão de latitude com longitude "num só numerão", a rigor precisa ser feita bit-a-bit conforme descrita <a href="https://stackoverflow.com/a/47369248/287948">nesta dica de algoritmo em linguagem C</a>. A seguir o algoritmo ingênuo tem a finalidade exclusiva de ser didático, mostrando como essa vontade de "fundir números num só", de forma um pouco mais inteligente, acabou levando aos algoritmos modernos de indexação baseados em curvas fractais.</p>
<p>No algoritmo mais ingênuo, descrito acima, a fusão é realizada por simples concatenação. Essa técnica é satisfatória em termos de compactação, mas apresenta inconvenientes no código resultante, porque leva a células vizinhas com prefixos diferentes. A estratégia de simplesmente intercalar os dígitos já figura como solução na representação decimal. Tomemos novamente o exemplo do MASP, com coordenadas locais <code>lat:=44549; lon:=17045;</code> intercalar é ir concatenando dígito a dígito, revezando entre as coordendas. Passo-a-passo:</p>
<ol>
<li>primeiro dígito de <code>lat</code> é <code>4</code>. Sobram <code>lat=4549</code> e fica <code>fundido=4</code>;</li>
<li>primeiro dígito de <code>lon</code> é <code>1</code>. Sobram <code>lon=7045</code> e fica <code>fundido=41</code>;</li>
<li>segundo dígito de <code>lat</code> é <code>4</code>. Sobram <code>lat=549</code> e fica <code>fundido=414</code>;</li>
<li>segundo dígito de <code>lon</code> é <code>7</code>. Sobram <code>lon=045</code> e fica <code>fundido=4147</code>;</li>
<li>... <code>fundido=4147504495</code>.</li>
</ol>
<p>Agora esse numerão fundido tem o mesmo comportamento por exemplo que o CEP: dois endereços sem primeiros dígitos iguais estarão a muitos quilômetros de distância, talvez extremos diferentes do país; com primeiros digamos 4 dígitos iguais estão numa mesma macro-região... E se diferem apenas nos dois últimos dígitos, são endereços vizinhos.</p>
<p>Repare que é tão compacto quanto a concatenação direta, o fundido decimal tem 10 dígitos e o base32 (<code>3RJBPBF</code>) 7 dígitos, como no caso concatenado. Sendo assim não há razão alguma para não fundir de forma mais inteligente!</p>
<p>Mas nem sempre dá sorte de todos os endereços de uma cidade, quando representados dessa forma,  terem um mesmo prefixozão, será um prefixozinho e isso não ajuda muito a compactar pelo "prefixo municipal".  Para se obter um prefixo municipal maior é preciso usar uma base numérica menor, ou seja, menor que a base10 no exemplo. E a menor base possível é a base2, por isso o algoritmo correto, mais eficiente é a intercalação em base2.</p>
<p><img alt="" src="../assets/bit-enterlace01.png" /></p>
<p>Esse pequeno milagre de preservar prefixo nas vizinhanças foi descoberto por acaso ao organizarmos melhor a concatenação, e tem uma explicação geométrica, pois o entrelaçamento resulta numa <a href="https://en.wikipedia.org/wiki/Z-order_curve">"curva de ordem Z"</a>... E justamente essa curva explica os problemas residuais de "saltos de vizinhança", que nem o algoritmo binário resolve.  Na verdade o algoritmo Geohash acrescentou uma pequena melhora, trocando as coordenadas usuais pela divisão binária recorrente do globo terrestre, mas ainda assim não resolve os saltos da curva Z.  Só a curva de Hilbert parece dar uma solução mais satisfatória. Ela é usada em algoritmos exóticos, como o <a href="https://github.com/tammoippen/geohash-hilbert">Geohash-hilbert</a>, e em algoritmos padronizados modernos, como o <a href="https://s2geometry.io/">S2-geometry</a>.</p>
<h2 id="indexacao-ingenua-da-grade-municipal">Indexação ingênua da grade municipal</h2>
<p>Para qualquer algoritmo de conversão das coordenadas num só código, consta-se que o código será mais compacto quanto menor for o município.</p>
<p>Assim, uma área municipal muito densa ou muito grande precisa ser subdividida em áreas menores, para garantir resultados mais compactos... Mas ao subdividir haverá o custo adicional de se indicar o código dessa área menor. Nisso consiste a indexação.</p>
<ul>
<li>
<p>ENTRADAS: geometria do polígono do município (<code>geom</code>) e parâmetros de cobertura, principalmente a quantidade-alvo de células na grade (<code>target</code> indicando 32 ou 1024).</p>
</li>
<li>
<p>SAÍDA: lista de identificadores de célula, tipicamente células S2. <code>cells</code>.</p>
</li>
</ul>
<p>Passo-a-passo, depois de padronizar a base do código resultante (nos exemplos usamos base32),</p>
<ol>
<li>
<p>Avaliar se a área do município (<code>geom</code>) requer zero, 1 ou 2 dígitos de indexação.<br/> No caso do exemplo "dígitos base32", de modo que seriam partições da área em zero (fica como está), 32 partes ou 1024 partes.  No caso de São Paulo, parece razoável um só dígito, ou seja, o resultado seria <code>target=32</code>.</p>
</li>
<li>
<p>Usar um algoritmo de partição qualquer (<em>S2</em> por exemplo), sem compromisso com o sistema de representação. Equivale a aplicar uma "grade de nível L" à área do município, onde L é o nível hierarquico da grade. Ajusta-se o melhor possível para particionar o máximo com o número de dígitos indicado pelo passo anterior.</p>
</li>
<li>
<p>Listar os identificadores de grade ou seu intervalo, como resultado em <code>cells</code>. A ordem dos elementos em <code>cells</code> já é o índice da célula (ex. valores de 0 a <code>target-1</code>) para aquele município.</p>
</li>
</ol>
<p><img alt="" src="../assets/otimizacao1.png" /></p>
<h3 id="rotulacao-ingenua-de-indices-contiguos">Rotulação ingênua de índices contíguos</h3>
<p>No caso de partição usando S2, que identifica cada célula por uma curva de Hilbert, a ordenação pelo índice em geral permitirá  ilustrar a sequência por intervalos associados a  áreas contíguas:</p>
<p><img alt="" src="../assets/Hilbert_curve02b.png" /></p>
<p>Áreas de células S2 típicas, ilustradas abaixo, são obtias por algoritmos de ajuste parâmetros e otimização, em  algoritmos mais sofisticados.</p>
<p>Algumas referências (ex. <a href="spec05-referencias.md#ref06">ref06</a>) sugerem associar áreas contíguas a subregiões que já apresentem nomes tradicionais, tais como nomes de bairro ou direções (leste/sul/etc.), criando opções de códigos mais mnemônicos no caso de indexação de dois dígitos.</p>
<p>Sugere-se que o uso de nomes seja sempre alternativo ao uso de códigos, nunca a única opção. Desse modo teríamos substituídos um ou dois dígitos por rótulos, por exemplo (um portão de Piracicaba SP) ao invés de <code>PIR-1234.456</code> o código seria <code>PIR-sul-234.456</code> ou <code>PIR-madalena-34.456</code>. A rotulação de regiões centro/norte/sul/etc em geral é a mais factivel, todavia causaria confunsão com a delimitação oficial e não chega a substituir um dígito por completo. A rotulação com palavras já seria bem mais artificial, não garante associação com nomes de regiões, apenas uma referência vaga (ex. palavra de nome de uma rua que nasce na célula ou de um parque do seu interior).</p>
<p>Uma opção mnemônica mais viável seria acrescentando um dígito decimal arbitrário ao nome da região, resultando em códigos como <code>PIR-sul2-34.456</code> ou <code>PIR-madalena3-4.456</code>, tendo em vista que a combinação nome-dígito pode ser suficiente para designar cada célula da subregião.</p></div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>var base_url = '..';</script>
        <script data-main="../mkdocs/js/search.js" src="../mkdocs/js/require.js"></script>
        <script src="../js/base.js"></script>
        <script src="../assets/leaflet-bing-layer.min.js"></script><div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
